<!DOCTYPE html>
<html lang="pl">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
        <link rel="stylesheet" href="../CSS/problems.css" type="text/css" />
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <title>Problemy</title>
    </head>

    <body>
        <div id="particles-js"></div>
        <div class="wrapper">
            <div class="typewriter">
                <h1>Teoria Grafów</h1>
            </div>

            <nav class="navigation">
                <ul class="navigation__item-list">
                    <li class="navigation__item">
                        <a href="main.html">Strona Główna</a>
                    </li>
                    <li class="navigation__item">
                        <a href="basicTerms.html">Podstawowa Terminologia</a>
                    </li>
                    <li class="navigation__item">
                        <a href="website.html">O stronie</a>
                    </li>
                    <li class="navigation__item">
                        <a href="author.html">O autorze</a>
                    </li>
                    <li class="navigation__item">
                        <a href="problems.html">Problemy</a>
                    </li>
                </ul>
            </nav>

            <main class="main">
                <div class="container">
                    <div class="main__div-math-bg"></div>
                    <h1 class="main__math-bg-heading">
                        Teoria grafów w informatyce algorytmicznej
                    </h1>
                </div>

                <div class="contents">
                    <h1 style="font-size: 450%;">
                        <span class="main__span-blue">Spis treści</span>
                    </h1>
                    <ul class="contents__item-list">
                        <li><h2>Reprezentacja grafu:<h2></li>
                        <ul>
                            <li data-target="main__edge-list-scroll" class="contents__list-item">Lista krawędzi <img src="../IMG/right-arrow-svgrepo-com.svg" height="30px" style="vertical-align: middle; margin-left: 20px;"></li>
                            <li data-target="main__adjacency-list-scroll" class="contents__list-item">Lista sąsiedztwa  <img src="../IMG/right-arrow-svgrepo-com.svg" height="30px" style="vertical-align: middle; margin-left: 20px;"></li>
                            <li data-target="main__adjacency-matrix-scroll" class="contents__list-item">Macierz sąsiedztwa <img src="../IMG/right-arrow-svgrepo-com.svg" height="30px" style="vertical-align: middle; margin-left: 20px;"></li>
                        </ul>
                        <li style="margin-top: 30px;"><h2>Algorytmy i Problemy:</h2></li>
                        <ul>
                            <li data-target="main__marriage-problem-scroll" class="contents__list-item">Problem kojarzenia małżeństw <img src="../IMG/right-arrow-svgrepo-com.svg" height="30px" style="vertical-align: middle; margin-left: 20px;"></li>
                            <li data-target="main__salesman-problem-scroll" class="contents__list-item">Problem komiwojażera <img src="../IMG/right-arrow-svgrepo-com.svg" height="30px" style="vertical-align: middle; margin-left: 20px;"></li>
                            <li data-target="main__shortest-path-problem-scroll" class="contents__list-item">Problem znajdywania najkrótszej ścieżki <img src="../IMG/right-arrow-svgrepo-com.svg" height="30px" style="vertical-align: middle; margin-left: 20px;"></li>
                            <li data-target="main__BFS-DFS-algo-scroll" class="contents__list-item">BFS i DFS <img src="../IMG/right-arrow-svgrepo-com.svg" height="30px" style="vertical-align: middle; margin-left: 20px;"></li>
                            <li data-target="main__find-cycle-scroll" class="contents__list-item">Znajdywanie cykli <img src="../IMG/right-arrow-svgrepo-com.svg" height="30px" style="vertical-align: middle; margin-left: 20px;"></li>
                            <li data-target="main__topological-sort-scroll" class="contents__list-item">Sortowanie topologiczne <img src="../IMG/right-arrow-svgrepo-com.svg" height="30px" style="vertical-align: middle; margin-left: 20px;"></li>
                        </ul>
                    </ul>
                    
                </div>

                <div class="main__wrapper">
                    <div class="divPattern">
                        <h1 class="main__h1-graph-representation">
                            Reprezentacja
                            <span class="main--colorFix">grafu</span>
                        </h1>
                        <p>
                            Istnieje kilka sposobów reprezentowania grafów,
                            każde z nich ma swoje wady i zalety, tutaj
                            przedstawię trzy z nich. Każdą z nich opisze za
                            pomocą paru kryteriów biorąc pod uwagę kwestie pamięciowe i
                            obliczeniowe:
                        </p>
                        <ul>
                            <li>Zajęta ilość pamięci</li>
                            <li>Dodanie krawędzi</li>
                            <li>Dodanie wierzchołka</li>
                            <li>Usunięcie krawędzi</li>
                            <li>Usunięcie wierzchołka</li>
                            <li>
                                Sprawdzenie sąsiedztwa dwóch wierzchołków (czy
                                są połączone krawędzią)
                            </li>
                        </ul>

                        <h2>
                            Pierwszym i najprostszym sposobem reprezentacji
                            grafu będzie:
                        </h2>

                        <h1 class="main__edge-list-scroll representation-type">Lista krawędzi</h1>
                        <p>
                            W tym sposobie każda krawędź grafu jest
                            przedstawiana jako para wierzchołków, które są nią
                            połączone. Cały graf jest zatem reprezentowany jako
                            lista takich par.
                        </p>
                        <p>Na przykład rozważmy graf skierowany(ten sam graf będzie w każdym przykładzie reprezentacji aby pokazać jego wady i zalety oraz podobieństwa i różnice):</p>
                        
                        <div style="display: flex; flex-wrap: wrap; justify-content: space-around; align-items: center;">
                            <div
                            class="graph-representation-visualisation-list graph-smaller"></div>

                            <ul style="text-align: center; font-size: larger; list-style-type: none;">
                                <li>\((A, B)\)</li>
                                <li style="margin-top: 15px;">\((B, C)\)</li>
                                <li style="margin-top: 15px;">\((B, D)\)</li>
                                <li style="margin-top: 15px;">\((C, A)\)</li>
                                <li style="margin-top: 15px;">\((D, A)\)</li>
                            </ul>
                        </div>
                        
                        
                        <h5>
                            W kwestii wydajności pamięciowej i obliczeniowej
                            sposób ten wygląda następująco:
                        </h5>
                        <ul>
                            <li>Zajęta ilość pamięci: \(O(∣E∣)\).</li>
                            <li>
                                Dodanie krawędzi: \(O(1)\), w najgorszym
                                przypadku \(O(∣E∣)\)
                            </li>
                            <li>
                                Dodanie wierzchołka: brak możliwości zapisania
                                wierzchołka niepołączonego żadną krawędzią.
                            </li>
                            <li>Usunięcie krawędzi: \(O(∣E∣)\).</li>
                            <li>
                                Usunięcie wierzchołka: \(O(∣E∣)\) — należy
                                przejść przez wszystkie krawędzie i usunąć te, w
                                których występuje wierzchołek.
                            </li>
                            <li>Sprawdzenie sąsiedztwa: \(O(∣E∣)\)</li>
                        </ul>
                        <p>
                            Reprezentacja grafu za pomocą listy krawędzi jest prosta i
                            ma zastosowanie chociażby w wizualizacji danych
                            poprzez możliwość dodania więcej niż jednego
                            wierzchołka do danej krawędzi. Posiada jednak jedną
                            kluczową wadę - wydajnościowo bez optymalizacji w
                            najgorszym przypadku musimy przebrnąć przez
                            \(O(∣E∣)\) operacji przez co nie najlepiej wpisuję
                            się w miano szybkiego sposobu.
                        </p>
                        <p>
                            Ciekawostka - do stworzenia grafów na tej stronie właśnie użyłem tego sposobu
                        </p>

                        <h1 class="main__adjacency-list-scroll representation-type">Lista sąsiedztwa</h1>
                        <p>
                            Jest to jeden z fundamentalnych sposobów
                            przedstawiania grafu. Najprościej powiemy że jest to
                            połączenie macierzy sąsiedztwa i listy krawędzi w
                            którym dla każdego wierzchołka przechowywana jest
                            lista jego sąsiadów.
                        </p>
                        <div style="display: flex; flex-wrap: wrap; justify-content: space-around; align-items: center;">
                            <div
                            class="graph-representation-visualisation-adjacency-list graph-smaller"></div>
                        

                            <ul style="margin-top: 50px; margin-bottom: 50px; text-align: center; font-size: larger; list-style-type: none;">
                                <li style="margin-top: 5px;">\(A ---> [B] \)</li>
                                <li style="margin-top: 5px;">\(B ---> [C, D]\)</li>
                                <li style="margin-top: 5px;">\(C ---> [A]\)</li>
                                <li style="margin-top: 5px;">\(D ---> [A]\)</li>
                            </ul>
                        </div>
                        
                        
                        <h5>
                            W kwestii wydajności pamięciowej i obliczeniowej
                            sposób ten wygląda następująco:
                        </h5>
                        <ul>
                            <li>Zajęta ilość pamięci: \(O(|V|+|E|)\).</li>
                            <li>Dodanie krawędzi: \(O(1)\)</li>
                            <li>Dodanie wierzchołka: \(O(1)\)</li>
                            <li>Usunięcie krawędzi: \(O(∣E∣)\).</li>
                            <li>Usunięcie wierzchołka: \(O(∣V∣)\)</li>
                            <li>Sprawdzenie sąsiedztwa: \(O(∣V∣)\)</li>
                        </ul>

                        <h1 class="main__adjacency-matrix-scroll representation-type">Macierz sąsiedztwa</h1>
                        <h3>
                            Macierz - Układ (w tym przypadku) liczb zapisanych w
                            tablicy dwuwymiarowej
                        </h3>
                        <h3>
                            Macierzą sąsiedztwa grafu nazywamy macierz \(A\) w
                            którym przedstawiamy liczbę krawędzi łączących
                            poszczególne wierzchołki.
                        </h3>
                        <p>Wymiary takiego macierza to \(|V| * |V|\).</p>
                        <p>
                            Rozpatrzmy taką sytuację - mamy graf skierowany i
                            chcemy przedstawić go w macierzy sąsiedztwa, jakie
                            są kolejne kroki?
                        </p>
                        <ol>
                            <li>Wybieramy jeden dowolny wierzchołek i oznaczamy go sobie jako pierwszy i patrzymy czy łączy się z następnymi.</li>
                            <ul>
                                <li>Wierzchołek pierwszy z pierwszym się nie łączy więc dajemy 0 (żeby dać tutaj 1 musiałaby być w danym wierzchołku pętla)</li>
                                <li>Wierzchołek pierwszy łączy się z drugim więc obok 0 dajemy 1</li>
                                <li>Wierzchołek pierwszy nie łączy się z trzecim więc obok 1 dajemy 0</li>
                                <li>Wierzchołek pierwszy nie łączy się z czwartym więc obok 0 dajemy znów 0</li>
                            </ul>
                            <li>Gdy skończymy porównywać pierwszy wierzchołek z kolejnymi powtarzamy czynność dopóki nie skończą nam się możliwe wierzchołki</li>
                        </ol>
                        <div style="display: flex; flex-wrap: wrap; justify-content: space-around; align-items: center;">
                            <div class="graph-representation-visualisation-adjacency-matrix graph-smaller"></div>
                            <p style="padding: 20px;">
                                \[ A = \begin{bmatrix} 
                                   0 & 1 & 0 & 0
                                \\ 0 & 0 & 1 & 1
                                \\ 1 & 0 & 0 & 0
                                \\ 1 & 0 & 0 & 0
                                \\ \end{bmatrix}
                                \]
                            </p>
                        </div>
                        

                        
                        <h5>
                            W kwestii wydajności pamięciowej i obliczeniowej
                            sposób ten wygląda następująco:
                        </h5>
                        <ul>
                            <li>Zajęta ilość pamięci: \(O(|V|^2)\).</li>
                            <li>Dodanie krawędzi: \(O(1)\)</li>
                            <li>Dodanie wierzchołka: \(O(V)^2\)</li>
                            <li>Usunięcie krawędzi: \(O(1)\).</li>
                            <li>Usunięcie wierzchołka: \(O(|V|^2)\)</li>
                            <li>Sprawdzenie sąsiedztwa: \(O(1)\)</li>
                        </ul>
                    </div>
                </div>

                <div class="main__algo_start">
                    <h1 class="main__h1-graph-representation"><span class="main--colorFix">Algorytmy</span> i <span class="main--colorFix">problemy</span></h1>
                </div>

                <div class="main__div-algorithm-about-wrapper">
                    <div class="main__div-algorithm-about">
                        <h1 class="main__div-algorithm-about-heading">
                            Ale czym tak naprawdę jest algorytm?
                        </h1>
                        <p class="main__div-algorithm-about-paragraph">
                            Najprościej możemy powiedzieć że jest to sposób
                            rozwiązania danego problemu
                        </p>
                    </div>

                    <img
                        class="arrow"
                        src="../SVG/down-arrow-svgrepo-com.svg" />

                    <div class="main__div-algorithm-about">
                        <p class="main__div-algorithm-about-paragraph">
                            Co za tym idzie, algorytm grafowy będzie
                            rozwiązaniem danego problemu za pomocą grafu.
                        </p>
                    </div>
                </div>

                <div class="divPattern main__marriage-problem-scroll">
                    <h1
                    class="main__h1 main__span-blue"
                    style="text-align: center;">
                    Kojarzenie małżeństw
                </h1>
                    
                    
                        <p>Twierdzenie to przypisywane jest Phillipowi Hallowi, który sformułował je w 1935r. </p>
                        <p>Problem polega na tym, że mamy: \(n\) panien i \(n\) kawalerów których chcemy dobrać w pary małżeńskie</p>
                        <h4>Warunkiem koniecznym oraz wystarczającym aby istniało takie skojarzenie jest to że dla dowolnej grupy chłopców \(k ∈ \{1, 2, . . . , n\}\) oni wspólnie znają co najmniej \(k\) dziewczyn</h4>
                    

                    <div class="marriage-div2">
                        <img src="../IMG/philip.jpg">
                        <p><b>Philip Hall</b> - brytyjski matematyk</p>
                    </div>

                    <div class="marriage-div3">
                        <h3>Problem będziemy rozwiązywali na życiowym przykładzie takim jaki przedstawiłem poyżej czyli:</h3>
                        
                            <div style="display: flex; justify-content: space-evenly;">
                                <div>
                                    <p style="text-align: center;">Mamy 5 panien: </p>
                                    <ul>
                                        <!--<li>Aleksandra</li>
                                        <li>Zosia</li>
                                        <li>Melania</li>
                                        <li>Barbara</li>
                                        <li>Asia</li>-->
                                        <li>Anna - 0</li>
                                        <li>Beata - 1</li>
                                        <li>Celina - 2</li>
                                        <li>Dorota - 3</li>
                                        <li>Ewa - 4</li>
                                    </ul>
                                </div>
                                

                                <div>
                                    <p style="text-align: center;">I 5 kawalerów</p>
                                    <ul>
                                        <!--<li>Piotrek</li>
                                        <li>Bartek</li>
                                        <li>Timothee</li>
                                        <li>Zbyszek</li>
                                        <li>Mateusz</li>-->
                                        <li>Fryderyk - 5</li>
                                        <li>Grzegorz - 6</li>
                                        <li>Henryk - 7</li>
                                        <li>Igor - 8</li>
                                        <li>Jan - 9</li>
                                    </ul>
                                </div>
                               
                            </div>
                        

                        <h4>Używając listy sąsiedztwa wytłumaczonej w sekcji interpretacji przedstawię teraz wygląd grafu</h4>
                        <div style="display: flex; justify-content: space-evenly; align-items: center;">
                            <ul>
                                <!--<li>Aleksandra   Timothee, Zbyszek</li>
                                <li>Zosia ->  Piotrek, Bartek, Zbyszek</li>
                                <li>Melania ->  Piotrek</li>
                                <li>Barbara ->  Bartek, Zbyszek, Mateusz</li>
                                <li>Asia ->  Zbyszek, Mateusz</li>-->
                                <li>Anna ---->   Henryk, Igor</li>
                                <li>Beata ---->  Fryderyk, Grzegorz, Igor</li>
                                <li>Celina ---->  Fryderyk</li>
                                <li>Dorota ---->  Grzegorz, Igor, Jan</li>
                                <li>Ewa ---->  Henryk, Igor</li>
                            </ul>
    
                            <img height="200px" src="../IMG/right-arrow-svgrepo-com.svg">
    
                            <ul>
                                <li>\(0 -> 7,8\)</li>
                                <li>\(1 -> 5,6,8\)</li>
                                <li>\(2 -> 5\)</li>
                                <li>\(3 -> 6,8,9\)</li>
                                <li>\(4 -> 7,8\)</li>
                            </ul>
                        </div>
                        
                        <h3 style="text-align: center;">Na podstawie tej listy tworzymy graf dwudzielny</h3>
                       
                        <div style="text-align: center;">
                            <div class="graph-smaller graph-marriage-first-step"></div>
                            <img src="../IMG/down-arrow-svgrepo-com.svg">
                            <p>Pierwszym naszym krokiem będzie połączenie pierwszej panny (Anny) z pierwszym akceptowanym przez nią kawalerem (Henrykiem), i tak naprawdę ten krok będzie naszą podstawą którą wykonujemy do momentu napotkania problemu</p>
                            <div class="graph-smaller graph-marriage-second-step"></div>
                            <img src="../IMG/down-arrow-svgrepo-com.svg">
                            <p>Następnie bierzemy kolejną pannę (Beatę) i łączymy ją z akceptowanym przez nią kawalerem (Fryderykiem)</p>
                            <div class="graph-smaller graph-marriage-third-step"></div>
                            <img src="../IMG/down-arrow-svgrepo-com.svg">
                            <p>Gdy spróbujemy połaczyć Celinę z Fryderykiem, okaże się, że jest on już zajęty. Lecz nic straconego, Beata lubi również Grzegorza i Igora. Więc jak się okazuję istnieje dla Celiny szansa. W tym celu zastosujemy <i>ścieżkę naprzemienną</i> - a jest to taka któa w grafie dwudzielnym przebiega naprzemian przez krawędzie skojarzone i nieskojarzone. Ścieżkę rozpoczynamy zawsze od krawędzi nieskojarzonej</p>
                            <div class="graph-smaller graph-marriage-fourth-step"></div>
                            <p>Ścieżka (czerwona linia) idzię od Celiny do Grzegorza przez Fryderyka oraz Beatę. Krawędzie czerwone są wolne, a zielone skojarzone</p>
                            <img src="../IMG/down-arrow-svgrepo-com.svg">
                            <p>Ścieżkę naprzemienną gdzie występują krawędzie wolne nazywamy ścieżką rozszerzającą, ponieważ za ich pomocą będziemy mogli rozszerzyć graf o kolejne skojarzenia. Aby to zrobić usuwamy krawędzie skojarzone w ścieżce rozszerzającej, a krawędzie wolne czynimy krawędziami skojarzonymi. W ten sposób Celina została zeswatana z Fryderykiem który wcześniej był już zajęty.</p>
                            <div class="graph-smaller graph-marriage-fifth-step"></div>
                            <img src="../IMG/down-arrow-svgrepo-com.svg">
                            <p>Wracamy do naszego początkowego algorytmu, patrzymy na następną pannę, Dorotę i widzimiy że lubi Igora który wciąż jest wolny, więc bez problemów łączymy </p>
                            <div class="graph-smaller graph-marriage-sixth-step"></div>
                            <img src="../IMG/down-arrow-svgrepo-com.svg">
                            <p>Pozostała jedynie para Ewa -> Igor jednak ewa nie chce za niego wyjść. Szukamy i tworzymy więc ścieżkę rozszerzającą od Ewy do Jana.</p>
                            <div class="graph-smaller graph-marriage-seventh-step"></div>
                            <img src="../IMG/down-arrow-svgrepo-com.svg">
                            <p>Ścieżka przebiega przez Igora oraz Dorotę. Teraz musimy tylko zamienić krawędzie wolne na skojarzone i skojarzone na wolne</p>
                            <div class="graph-smaller graph-marriage-eighth-step"></div>
                            <h2>Tak wygląda skojarzenie pełne w tym grafie dwudzielnym</h3>
                        </div>
                        
                    </div>

                </div>


                <div class="divPattern main__salesman-problem-scroll">
                    <h1
                    class="main__h1 main__span-blue"
                    style="text-align: center">
                    Problem komiwojażera
                </h1>
                    
                    <div>
                        <p>Jest to zagadnienie polegające na optymalizacji drogi pod względem odległości, ceny, czasu podróży. Problem mówi o sprzedawcy który podróżuje od miasta do miasta, wyrusza ze swojej miejscowości rodzinnej, na swojej handlowej drodze przechodzi przez każde miasto dokładnie jeden raz, zależy mu na tym aby droga którą pójdzie była najkrótszą możliwą. Na koniec wędrówki wraca do miasta rodzinnego.</p>
                        <p>Eksplorując ten problem będziemy chcieli znaleźć odpowiedź na pytanie: Jaka jest najkrótsza droga która przechodzi przez każde miasto i wraca do punktu wyjścia.</p>
                        <p>Tłumacząc wstęp na język matematyki: miasta to wierzchołki, a szlak po którym wędruje sprzedawca to krawędzie z wagami. Jak na początku wspomniałem, drogę możemy zoptymalizować pod wieloma względami, za to będa odpowiedzialne wagi.</p>
                        <div class="theorem">
                            <h1>Finalnie...</h1>
                            <p>Jak znaleźć minimalny cykl Hamiltona w pełnym(jeżeli mówimy o np modelu budowy dróg między miastami nie musimy brać pod uwagę grafu pełnego, w założeniu jest to podejście najbardziej pesymistyczne) grafie ważonym.</p>
                        </div>
                        <p>Problem podróży sprzedawców po miastach był już rozważany w pierwszej połowie XIX w. przez Williama Rowana Hamilltona jednak wtedy problem nie zawierał żadnych matematycznych uzasadnień. Problem szczegółowo został opisany dopiero w 1930r. przez austriackiego matematyka Karla Mengera. Zdawał on sobie wtedy również sprawę ze złożoności tego problemu</p>
                    </div>

                    <div style="display: flex; align-items: center; justify-content: space-around; flex-wrap: wrap;">
                        <div style="text-align: center;">
                            <img height="250px" src="../IMG/menger.jpg">
                            <p><b>Karl Menger</b></p>
                        </div>
                        <div style="text-align: center;">
                            <img height="250px" src="../IMG/hamillton.jpeg"">
                            <p><b>William Rowan Hamillton</b></p>
                        </div>
                    </div>
                        
                    <div style="margin-top: 50px;">
                        <div class="theorem">
                            <p>Zagadnienie należy do typu problemów NP-trudnych czyli - nie istnieje dla niego rozwiązanie ze złożonością wielomianową i niestety nie istnieje dla niego ogólny i efektywny algorytm dający optymalne rozwiązanie. </p>
                            <p>Jednakże mamy jeszczę wersję decyzyjną tego problemu, wtedy mamy daną liczbę \(x\) i graf, mamy odpowiedzieć na pytanie czy istnieje trasa komiwojażera czyli cykl krótszy od \(x\)</p>
                        </div>
                        
                        <p style="text-align: center; margin-top: 60px;">Dla n miast liczba kombinacji wynosi</p>
                        <p style="text-align: center; font-size: xx-large">\({{(n-1)!} \over 2}\)</p>

                        <p style="text-align: center; margin-top: 60px;">Dla 20 miast liczba cykli hamilltona wynosi</p>
                        <p style="text-align: center; font-size: xx-large">\({{(20-1)!} \over 2} = {19! \over 2} = 6 * 10^{16}\)</p>

                        <h2 style="text-align: center; margin-top: 100px;">Sposoby rozwiązywania problemu komiwojażera</h2>
                        <ul>
                            <li>Algorytm Helda-Karpa</li>
                            <li>Algorytm najbliższego sąsiada:</li>
                            <li>Algorytm mrówkowy</li>
                            <li>Symulowane wyżarzanie</li>
                            <li>Algorytm Christofidesa</li>
                        </ul>
                        
                        <h2>Poniżej znajduję się algorytm w pseudokodzie odpowiedzialny za rozwiązanie problemu komiwojażera ale tylko dla grafów o ograniczonej ilości węzłów.</h2>
                        
                    </div>
                </div>

                <div class="problem-div main__shortest-path-problem-scroll">
                    <h1><span class="main--colorFix">Problem znajdywania najkrótszej ścieżki </span></h1>

                    <p>Autorem tego twierdzenia jest ...</p>
                </div>

                <div class="main__marriage_problem problem-div main__BFS-DFS-algo-scroll">
                    <h1><span class="main--colorFix">BFS i DFS</span></h1>

                    <p>Autorem tego twierdzenia jest ...</p>
                </div>

                <div class="main__marriage_problem problem-div main__find-cycle-scroll">
                    <h1><span class="main--colorFix">Znajdywanie cykli</span></h1>

                    <p>Autorem tego twierdzenia jest ...</p>
                </div>

                <div class="main__marriage_problem problem-div main__topological-sort-scroll">
                    <h1><span class="main--colorFix">Sortowanie topologiczne</span></h1>

                    <p>Autorem tego twierdzenia jest ...</p>
                </div>
            </main>
            <footer class="footer">
                <svg
                    class="waves"
                    xmlns="http://www.w3.org/2000/svg"
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    viewBox="0 24 150 28"
                    preserveAspectRatio="none"
                    shape-rendering="auto">
                    <defs>
                        <path
                            id="gentle-wave"
                            d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
                    </defs>
                    <g class="parallax">
                        <use
                            xlink:href="#gentle-wave"
                            x="48"
                            y="0"
                            fill="rgba(255,255,255,0.7)" />
                        <use
                            xlink:href="#gentle-wave"
                            x="48"
                            y="3"
                            fill="rgba(255,255,255,0.5)" />
                        <use
                            xlink:href="#gentle-wave"
                            x="48"
                            y="5"
                            fill="rgba(255,255,255,0.3)" />
                        <use
                            xlink:href="#gentle-wave"
                            x="48"
                            y="7"
                            fill="#fff" />
                    </g>
                </svg>
            </footer>
        </div>

        <script src="../JS/script.js"></script>
        <script src="../JS/particles.js"></script>
        <script src="../JS/app.js"></script>
        <script src="../JS/connectedGraph.js"></script>
        <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script
            id="MathJax-script"
            async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="../JS/graphs/marriage/marriage-first.js"></script>
        <script src="../JS/graphs/marriage/marriage-second.js"></script>
        <script src="../JS/graphs/marriage/marriage-third.js"></script>
        <script src="../JS/graphs/marriage/marriage-fourth.js"></script>
        <script src="../JS/graphs/marriage/marriage-fifth.js"></script>
        <script src="../JS/graphs/marriage/marriage-sixth.js"></script>
        <script src="../JS/graphs/marriage/marriage-seventh.js"></script>
        <script src="../JS/graphs/marriage/marriage-eighth.js"></script>
        <script src="../JS/graphs/representation/edgeList.js"></script>
        <script src="../JS/graphs/representation/adjacencyList.js"></script>
        <script src="../JS/graphs/representation/adjacencyMatrix.js"></script>
        <script src="../JS/scroll.js"></script>
    </body>
</html>
